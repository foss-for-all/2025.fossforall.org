---
const { lang } = Astro.props;
import { renderMarkdown } from "@/lib/utils";
import { WebsiteConfig } from "@/config";
import { createHash } from 'crypto';
import type { Speaker } from "@/models/Speaker";
import { SpeakerCardAndModal } from "@/components/SpeakerCardAndModal";
import { SpeakerOrganizations } from "@/data/speakerOrganizations";

const config = WebsiteConfig(lang);

interface Submission {
    code: string;
    title: string;
    speakers: string[];
    submission_type: number;
    track: number;
    content_locale: string;
}

interface Track {
    id: number;
    name: Map<string, string>;
}

const response = await fetch(
    `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/speakers/`,
    {
        headers: new Headers({
            Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
        }),
    },
);
let speakers: Speaker[] = (await response.json())["results"];
const {
  speakersToExpose = [],
} = Astro.props;

// Fetch sessions data
const sessionResponse = await fetch(
    `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/submissions/?state=confirmed`,
    {
        headers: new Headers({
            Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
        }),
    },
);
const sessions: Submission[] = (await sessionResponse.json())["results"];

// Fetch tracks data
const trackResponse = await fetch(
    `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/tracks/`,
    {
        headers: new Headers({
            Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
        }),
    },
);
const tracks: Track[] = (await trackResponse.json())["results"];

// Merge local organization data with API speaker data
speakers = speakers.map((speaker) => {
    const orgData = SpeakerOrganizations.find(
        (org) => org.name === speaker.name
    );
    return {
        ...speaker,
        organization: orgData?.organization || speaker.organization,
    };
});

// Process markdown in biography at build time
speakers = await Promise.all(speakers.map(async (speaker) => ({
    ...speaker,
    biography: await renderMarkdown(speaker.biography),
})));
---

<div class="columns is-multiline">
    {
        speakers.map((speaker: Speaker) => speakersToExpose.includes(speaker.code) ? (
        <SpeakerCardAndModal client:load speaker={speaker} sessions={sessions} tracks={tracks} config={config} lang={lang} gravatarHash={createHash("SHA256").update(speaker.email, "utf-8").digest("hex")} />
        ):(<></>))
    }
</div>
