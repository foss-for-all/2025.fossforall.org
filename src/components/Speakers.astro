---
const { lang, speakersToExpose = [] } = Astro.props;
import { useTranslations } from "@/i18n/utils";
import { renderMarkdown } from "@/lib/utils";
import { WebsiteConfig } from "@/config";
import { createHash } from 'crypto';
import type { Speaker } from "@/models/Speaker";
import { SpeakerCardAndModal } from "@/components/SpeakerCardAndModal";
import { SpeakerOrganizations } from "@/data/speakerOrganizations";

const config = WebsiteConfig(lang);
const t = useTranslations(lang);

interface Submission {
    code: string;
    title: string;
    speakers: string[];
    submission_type: number;
    track: number;
    content_locale: string;
}

interface Track {
    id: number;
    name: Map<string, string>;
}

async function fetchAll(url: string, headers: Headers): Promise<any[]> {
    let results: any[] = [];
    let nextUrl: string | null = url;

    while (nextUrl) {
        const response = await fetch(nextUrl, { headers });
        const data = await response.json();
        if (data?.results) {
            results = results.concat(data.results);
        }
        nextUrl = data?.next || null;
    }
    return results;
}

const headers = new Headers({
    Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
});

const speakersUrl = `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/speakers/`;
let speakers: Speaker[] = await fetchAll(speakersUrl, headers);

const submissionsUrl = `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/submissions/?state=confirmed`;
const sessions: Submission[] = await fetchAll(submissionsUrl, headers);

const tracksUrl = `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/tracks/`;
const tracks: Track[] = await fetchAll(tracksUrl, headers);

// Filter speakers to only include those with confirmed submissions
const acceptedSpeakerCodes = new Set<string>();
sessions.forEach(session => {
    session.speakers.forEach(speakerCode => {
        acceptedSpeakerCodes.add(speakerCode);
    });
});
speakers = speakers.filter(speaker => acceptedSpeakerCodes.has(speaker.code));

// Merge local organization data with API speaker data
speakers = speakers.map((speaker) => {
    const orgData = SpeakerOrganizations.find(
        (org) => org.name === speaker.name
    );
    return {
        ...speaker,
        organization: orgData?.organization || speaker.organization,
    };
});

// Process markdown in biography at build time
speakers = await Promise.all(speakers.map(async (speaker) => ({
    ...speaker,
    biography: await renderMarkdown(speaker.biography),
})));

const keynoteSpeakerCodes = config.pretalx.keynoteSpeakers;
const keynoteSpeakers = speakers.filter(s => keynoteSpeakerCodes.includes(s.code));
const otherSpeakers = speakers.filter(s => !keynoteSpeakerCodes.includes(s.code));
---

<h2 class="title is-2">{t('speakers.keynote')}</h2>
<div class="columns is-multiline">
    {
        keynoteSpeakers
            .filter((speaker: Speaker) => speakersToExpose.length === 0 || speakersToExpose.includes(speaker.code))
            .map((speaker: Speaker) => (
                <SpeakerCardAndModal client:load speaker={speaker} sessions={sessions} tracks={tracks} config={config} lang={lang} gravatarHash={createHash("SHA256").update(speaker.email || "", "utf-8").digest("hex")} />
            ))
    }
</div>

<h2 class="title is-2">{t('speakers.general')}</h2>
<div class="columns is-multiline">
    {
        otherSpeakers
            .filter((speaker: Speaker) => speakersToExpose.length === 0 || speakersToExpose.includes(speaker.code))
            .map((speaker: Speaker) => (
                <SpeakerCardAndModal client:load speaker={speaker} sessions={sessions} tracks={tracks} config={config} lang={lang} gravatarHash={createHash("SHA256").update(speaker.email || "", "utf-8").digest("hex")} />
            ))
    }
</div>