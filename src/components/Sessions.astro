---
const { lang } = Astro.props;
import { WebsiteConfig } from "@/config";

const config = WebsiteConfig(lang);

interface Submission {
    code: string;
    title: string;
    speakers: string[];
    submission_type: number;
    track: number;
    tags: number[];
    state: string;
    abstract: string;
    description: string;
    duration: number;
    slot_count: number;
    content_locale: string;
    do_not_record: boolean;
    image: string;
    resources: number[];
    slots: number[];
    answers: number[];
}

interface Speaker {
    code: string;
    name: string;
    biography: string;
    submissions: string[];
    avatar_url: string;
    answers: string[];
    email: string;
    timezone: string;
    locale: string;
    has_arrived: boolean;
}

interface Track {
    id: number;
    name: Map<string, string>;
    description: Map<string, string>;
    color: string;
    position: number;
    requires_access_code: boolean;
}

interface SubmissionType {
    id: number;
    name: string;
}

const sessionResponse = await fetch(
    `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/submissions/?state=confirmed`,
    {
        headers: new Headers({
            Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
        }),
    },
);
const sessionData = await sessionResponse.json();
const sessions: Submission[] = sessionData?.results || [];

const speakerResponse = await fetch(
    `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/speakers/`,
    {
        headers: new Headers({
            Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
        }),
    },
);
const speakerData = await speakerResponse.json();
const speakers: Speaker[] = speakerData?.results || [];

const trackResponse = await fetch(
    `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/tracks/`,
    {
        headers: new Headers({
            Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
        }),
    },
);
const trackData = await trackResponse.json();
const tracks: Track[] = trackData?.results || [];

let submissionTypes: SubmissionType[] = [];
try {
    const submissionTypeResponse = await fetch(
        `${config.pretalx.baseUrl}/api/events/${config.pretalx.eventSlug}/submission_types/`,
        {
            headers: new Headers({
                Authorization: "Token " + import.meta.env.PRETALX_TOKEN,
            }),
        },
    );
    if (submissionTypeResponse.ok) {
        submissionTypes = (await submissionTypeResponse.json())["results"];
    }
} catch (error) {
    console.error("Failed to fetch submission types:", error);
}

// Map submission type IDs to display names
const typeIdToName: { [key: number]: string } = {
    1: "Session",
    8: "Lightning Talk",
};

// Find keynote speakers (Hong Minhee and RichiH)
const keynoteSpakers = speakers
    .filter(
        (speaker) =>
            speaker.name.includes("Hong Minhee") ||
            speaker.name.includes("RichiH"),
    )
    .map((speaker) => speaker.code);

// Group sessions: separate keynotes from other submissions by type
interface GroupedSessionsMap {
    [key: string]: Submission[];
}
const groupedSessions: GroupedSessionsMap = {
    Keynote: [],
};

sessions.forEach((session) => {
    // Check if this is a keynote (has keynote speakers)
    const isKeynote = session.speakers.some((speaker) =>
        keynoteSpakers.includes(speaker),
    );

    if (isKeynote) {
        groupedSessions["Keynote"].push(session);
    } else {
        // Group by submission type name
        const typeName =
            typeIdToName[session.submission_type] ||
            submissionTypes.find((t) => t.id === session.submission_type)?.name ||
            `Type ${session.submission_type}`;
        if (!groupedSessions[typeName]) {
            groupedSessions[typeName] = [];
        }
        groupedSessions[typeName].push(session);
    }
});

// Define custom sort order for submission types
const typeOrder = ["Keynote", "Session", "Lightning Talk"];

// Sort groups by custom order
const sortedGroups = Object.entries(groupedSessions).sort((a, b) => {
    const indexA = typeOrder.findIndex((type) =>
        a[0].toLowerCase().includes(type.toLowerCase()),
    );
    const indexB = typeOrder.findIndex((type) =>
        b[0].toLowerCase().includes(type.toLowerCase()),
    );

    // If both are in the order list, use that order
    if (indexA !== -1 && indexB !== -1) return indexA - indexB;
    // If only one is in the order list, prioritize it
    if (indexA !== -1) return -1;
    if (indexB !== -1) return 1;
    // Otherwise, keep alphabetical order
    return a[0].localeCompare(b[0]);
});
---

<div class="columns is-multiline">
    {
        sortedGroups.map(([typeName, groupSessions]) => (
            <>
                <div class="column is-full">
                    <h2 class="title is-3" style="margin-top: 2rem; margin-bottom: 1rem;">
                        {typeName}
                    </h2>
                </div>
                {groupSessions.map((session: Submission) => (
                    <div class="column is-full">
                        <a
                            href={`${config.pretalx.baseUrl}/${config.pretalx.eventSlug}/talk/${session.code}`}
                            class="session-card-link"
                        >
                            <div class="card">
                                <div class="card-content">
                                    <p class="title is-4">{session.title}</p>
                                    <div class="content">
                                        {session.speakers.map((item) => (
                                            <>
                                                <span class="icon">
                                                    <i class="fa-solid fa-person" />
                                                </span>
                                                <span>
                                                    {
                                                        speakers.find(
                                                            (speaker) =>
                                                                speaker.code == item,
                                                        )?.name
                                                    }
                                                </span>
                                            </>
                                        ))}
                                        <span class="icon">
                                            <i class="fa-solid fa-tags" />
                                        </span>
                                        <span>
                                            {
                                                tracks.find(
                                                    (track) => track.id == session.track,
                                                )?.name[lang]
                                            }
                                        </span>
                                        <span class="icon">
                                            <i class="fa-solid fa-language" />
                                        </span>
                                        <span>{session.content_locale}</span>
                                    </div>
                                </div>
                            </div>
                        </a>
                    </div>
                ))}
            </>
        ))
    }
</div>

<style>
    .session-card-link {
        text-decoration: none;
        color: inherit;
        display: block;
    }

    .session-card-link .card {
        cursor: pointer;
        transition: transform 0.2s ease;
    }

    .session-card-link:hover .card {
        transform: translateY(-2px);
        box-shadow: 0 0.5em 1em -0.125em rgba(10, 10, 10, 0.1),
            0 0px 0 1px rgba(10, 10, 10, 0.02);
    }
</style>
